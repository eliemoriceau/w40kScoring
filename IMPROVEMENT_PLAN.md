# üöÄ Plan d'Am√©lioration Technique - W40K Scoring

**Approche** : Excellence Technique avec Refonte Optimis√©e  
**√âquipe** : 1 d√©veloppeur interm√©diaire + Claude Code  
**Contexte** : Volume mod√©r√© (<10 utilisateurs), donn√©es critiques, budget serr√©

---

## üéØ Strat√©gie Globale

### **Principe Directeur**

> **"Excellence technique sans compromis, solutions pragmatiques et √©conomiques"**

### **Stack Technique Optimis√©e**

- **Base actuelle** : AdonisJS 6 + Vue 3 ‚úÖ (excellente, on garde)
- **Ajouts propos√©s** :
  - **SQLite en dev** ‚Üí **PostgreSQL optimis√©** (d√©j√† en place)
  - **Cache applicatif** ‚Üí Solution Node.js native (sans Redis)
  - **Monitoring** ‚Üí Pino + structured logging
  - **Security** ‚Üí Shield + Helmet complets

---

## üìã Phase 1: Corrections Critiques S√©curitaires

### **üö® Priorit√© Absolue (D√©lai: 3-5 jours)**

#### **1.1 √âlimination Logs Sensibles**

```typescript
// ‚ùå AVANT (admin_user_service.ts:378,384)
console.log(`Welcome email would be sent to ${user.email} with temp password: ${tempPassword}`)

// ‚úÖ APR√àS - Solution s√©curis√©e
import logger from '@adonisjs/core/services/logger'

// Logging s√©curis√© avec structure
logger.info('User password reset initiated', {
  userId: user.id,
  userEmail: user.email.replace(/(.{2}).*(@.*)/, '$1***$2'), // Email masqu√©
  action: 'password_reset',
  timestamp: DateTime.now().toISO(),
  // ‚ùå JAMAIS de mot de passe dans les logs
})

// Service de notification s√©par√©
class SecureNotificationService {
  private async sendPasswordEmail(user: User, tempPassword: string) {
    // Email envoy√© directement sans logging du password
    logger.info(`Password reset email queued for user ${user.id}`)
  }
}
```

#### **1.2 S√©curisation CORS Compl√®te**

```typescript
// config/cors.ts - Configuration production-ready
import env from '#start/env'

const corsConfig = defineConfig({
  enabled: true,
  origin: (origin, callback) => {
    // Environnement-specific origins
    const allowedOrigins =
      env.get('NODE_ENV') === 'production'
        ? ['https://w40kscoring.yourdomain.com', 'https://www.w40kscoring.yourdomain.com']
        : [
            'http://localhost:3333',
            'http://localhost:5173', // Vite dev server
            'http://127.0.0.1:3333',
          ]

    // Allow no origin (pour les apps mobiles futures)
    if (!origin) return callback(null, true)

    if (allowedOrigins.includes(origin)) {
      callback(null, true)
    } else {
      logger.warn(`CORS blocked origin: ${origin}`)
      callback(new Error('CORS policy violation'), false)
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  headers: [
    'Origin',
    'X-Requested-With',
    'Content-Type',
    'Accept',
    'Authorization',
    'X-CSRF-Token',
  ],
  maxAge: 86400, // 24h cache des preflight
})
```

#### **1.3 Content Security Policy Robuste**

```typescript
// config/shield.ts - CSP complet pour W40K app
import { defineConfig } from '@adonisjs/shield'

const shieldConfig = defineConfig({
  csp: {
    enabled: true,
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: [
        "'self'",
        "'unsafe-inline'", // Pour Inertia.js (minimal n√©cessaire)
        '@viteDevUrl', // Dev uniquement
        '@viteUrl', // Production
      ],
      styleSrc: [
        "'self'",
        "'unsafe-inline'", // Pour Tailwind utilities
        'https://fonts.googleapis.com', // Si Google Fonts utilis√©es
      ],
      imgSrc: [
        "'self'",
        'data:', // Pour les avatars base64 futurs
        'https:', // Images externes W40K si n√©cessaire
      ],
      fontSrc: ["'self'", 'https://fonts.googleapis.com', 'https://fonts.gstatic.com'],
      connectSrc: [
        "'self'",
        '@viteHmrUrl', // HMR dev
      ],
      frameSrc: ["'none'"], // Pas d'iframe
      objectSrc: ["'none'"], // S√©curit√©
      upgradeInsecureRequests: [], // Force HTTPS en prod
    },
    reportOnly: false, // Active en production
  },

  // Headers s√©curitaires additionnels
  hsts: {
    enabled: true,
    maxAge: '1 year',
    includeSubDomains: true,
  },

  xFrame: {
    enabled: true,
    action: 'DENY', // Anti-clickjacking
  },

  contentTypeSniffing: {
    enabled: true, // Anti-MIME sniffing
  },
})
```

#### **1.4 Rate Limiting Complet**

```typescript
// middleware/enhanced_rate_limit_middleware.ts
import { HttpContext } from '@adonisjs/core/http'
import { NextFn } from '@adonisjs/core/types/http'

interface RateLimitConfig {
  windowMs: number
  maxRequests: number
  skipSuccessful?: boolean
}

class EnhancedRateLimitMiddleware {
  // Configuration par endpoint
  private configs: Record<string, RateLimitConfig> = {
    'auth:login': { windowMs: 15 * 60 * 1000, maxRequests: 5 }, // 5 tentatives/15min
    'auth:register': { windowMs: 60 * 60 * 1000, maxRequests: 3 }, // 3 inscriptions/h
    'admin:*': { windowMs: 5 * 60 * 1000, maxRequests: 100 }, // 100 actions admin/5min
    'api:*': { windowMs: 60 * 1000, maxRequests: 60 }, // 60 req/min par d√©faut
    'password:reset': { windowMs: 60 * 60 * 1000, maxRequests: 3 }, // 3 reset/h
  }

  async handle({ request, response, session }: HttpContext, next: NextFn) {
    const key = this.getRouteKey(request)
    const config = this.getConfig(key)

    if (!config) return next()

    const identifier = this.getIdentifier(request, session)
    const isAllowed = await this.checkRateLimit(identifier, key, config)

    if (!isAllowed) {
      logger.warn(`Rate limit exceeded`, {
        ip: request.ip(),
        route: key,
        userAgent: request.header('user-agent'),
      })

      return response.tooManyRequests({
        error: 'Trop de tentatives. Veuillez patienter.',
        retryAfter: config.windowMs / 1000,
      })
    }

    return next()
  }
}
```

---

## üîß Phase 2: Optimisation Performance Critique

### **üöÄ Architecture de Donn√©es (D√©lai: 1 semaine)**

#### **2.1 R√©solution N+1 Queries - Solution DDD**

```typescript
// domain/repositories/enhanced_score_repository.ts
interface ScoreQueryRepository {
  // ‚úÖ Nouvelle m√©thode optimis√©e
  findByGameIdWithRounds(gameId: GameId): Promise<Score[]>
  findScoresByGameIdGroupedByRound(gameId: GameId): Promise<Map<RoundId, Score[]>>
}

// infrastructure/repositories/lucid_score_query_repository.ts
export class LucidScoreQueryRepository implements ScoreQueryRepository {
  async findByGameIdWithRounds(gameId: GameId): Promise<Score[]> {
    // üöÄ Une seule requ√™te optimis√©e avec JOIN
    const scoreModels = await ScoreModel.query()
      .join('rounds', 'scores.round_id', 'rounds.id')
      .where('rounds.game_id', gameId.value)
      .preload('round') // Eager loading
      .orderBy('rounds.round_number')
      .orderBy('scores.created_at')

    return scoreModels.map((model) => this.toDomainEntity(model))
  }

  async findScoresByGameIdGroupedByRound(gameId: GameId): Promise<Map<RoundId, Score[]>> {
    const scores = await this.findByGameIdWithRounds(gameId)

    // Groupement en m√©moire (plus efficace que plusieurs requ√™tes)
    const groupedScores = new Map<RoundId, Score[]>()

    for (const score of scores) {
      const roundId = score.roundId
      if (!groupedScores.has(roundId)) {
        groupedScores.set(roundId, [])
      }
      groupedScores.get(roundId)!.push(score)
    }

    return groupedScores
  }
}

// application/services/game_detail_service.ts - REFACTOR√â
export class GameDetailService {
  // ‚úÖ APR√àS - Une seule requ√™te
  private async getScoresForGame(gameId: GameId): Promise<Score[]> {
    return await this.scoreQueryRepository.findByGameIdWithRounds(gameId)
  }

  // ‚úÖ M√©thode optimis√©e pour le dashboard
  private async getScoresGroupedByRound(gameId: GameId): Promise<Map<RoundId, Score[]>> {
    return await this.scoreQueryRepository.findScoresByGameIdGroupedByRound(gameId)
  }
}
```

#### **2.2 Cache Applicatif Intelligent (sans Redis)**

```typescript
// infrastructure/cache/memory_cache_service.ts
import { LRUCache } from 'lru-cache'

interface CacheOptions {
  maxSize: number
  ttlMs: number
  staleWhileRevalidate?: number
}

class MemoryCacheService {
  private caches: Map<string, LRUCache<string, any>> = new Map()

  constructor() {
    // Caches sp√©cialis√©s par domaine
    this.createCache('game_details', { maxSize: 100, ttlMs: 5 * 60 * 1000 }) // 5min
    this.createCache('user_sessions', { maxSize: 50, ttlMs: 30 * 60 * 1000 }) // 30min
    this.createCache('static_data', { maxSize: 20, ttlMs: 60 * 60 * 1000 }) // 1h
  }

  private createCache(name: string, options: CacheOptions): void {
    this.caches.set(
      name,
      new LRUCache({
        max: options.maxSize,
        ttl: options.ttlMs,
        allowStale: true,
        updateAgeOnGet: true,
      })
    )
  }

  async get<T>(cacheName: string, key: string): Promise<T | null> {
    const cache = this.caches.get(cacheName)
    return cache?.get(key) || null
  }

  async set<T>(cacheName: string, key: string, value: T): Promise<void> {
    const cache = this.caches.get(cacheName)
    cache?.set(key, value)
  }

  // Pattern cache-aside avec fallback automatique
  async getOrSet<T>(cacheName: string, key: string, fallbackFn: () => Promise<T>): Promise<T> {
    let cached = await this.get<T>(cacheName, key)

    if (cached !== null) {
      return cached
    }

    const fresh = await fallbackFn()
    await this.set(cacheName, key, fresh)
    return fresh
  }
}

// application/services/cached_game_detail_service.ts
export class CachedGameDetailService extends GameDetailService {
  constructor(
    private cache: MemoryCacheService,
    ...baseParams: ConstructorParameters<typeof GameDetailService>
  ) {
    super(...baseParams)
  }

  async getGameDetail(gameId: GameId, userId: number): Promise<GameDetailSummary | null> {
    const cacheKey = `${gameId.value}:${userId}`

    return await this.cache.getOrSet('game_details', cacheKey, () =>
      super.getGameDetail(gameId, userId)
    )
  }

  // Invalidation intelligente lors des updates
  async invalidateGameCache(gameId: GameId): Promise<void> {
    // Pattern de cache busting par pr√©fixe
    const cache = this.cache.getCacheInstance('game_details')
    const keysToDelete = Array.from(cache.keys()).filter((key) =>
      key.startsWith(`${gameId.value}:`)
    )

    keysToDelete.forEach((key) => cache.delete(key))

    logger.debug(`Cache invalidated for game ${gameId.value}`, {
      keysDeleted: keysToDelete.length,
    })
  }
}
```

#### **2.3 Injection de D√©pendances Professionnelle**

```typescript
// providers/repositories_provider.ts
import { ApplicationService } from '@adonisjs/core/types'

export default class RepositoriesProvider {
  constructor(protected app: ApplicationService) {}

  async register() {
    // Repositories singletons
    this.app.container.singleton('GameQueryRepository', () => {
      return new LucidGameQueryRepository()
    })

    this.app.container.singleton('ScoreQueryRepository', () => {
      return new LucidScoreQueryRepository()
    })

    // Services avec d√©pendances
    this.app.container.singleton('CacheService', () => {
      return new MemoryCacheService()
    })

    this.app.container.singleton('GameDetailService', () => {
      return new CachedGameDetailService(
        this.app.container.use('CacheService'),
        this.app.container.use('GameQueryRepository'),
        this.app.container.use('ScoreQueryRepository')
        // ... autres d√©pendances
      )
    })
  }
}

// controllers/parties_controller.ts - REFACTOR√â
import { inject } from '@adonisjs/core'
import type { GameDetailService } from '#application/services/game_detail_service'

@inject()
export default class PartiesController {
  constructor(
    private gameDetailService: GameDetailService,
    private gameCreationService: GameCreationService,
    private userSearchService: UserSearchService
  ) {}

  // ‚úÖ Plus d'instanciation manuelle, IoC automatique
  async show({ params, auth, inertia }: HttpContext) {
    // Service d√©j√† inject√© et optimis√©
    const gameDetail = await this.gameDetailService.getGameDetail(
      new GameId(params.id),
      auth.user!.id
    )

    return inertia.render('parties/show', { game: gameDetail })
  }
}
```

---

## üé® Phase 3: Refonte Frontend Optimis√©e

### **üß© D√©composition Composants (D√©lai: 1 semaine)**

#### **3.1 Architecture Composants W40K**

```vue
<!-- components/game/W40KScoreBoard.vue - Composant orchestrateur -->
<template>
  <div class="w40k-scoreboard">
    <W40KGameHeader :game="game" :currentRound="currentRound" @round-change="handleRoundChange" />

    <W40KPlayerGrid
      :players="game.players"
      :scores="currentRoundScores"
      :editable="canEdit"
      @score-update="handleScoreUpdate"
    />

    <W40KSecondaryObjectives
      v-if="showSecondaries"
      :objectives="secondaryObjectives"
      :playerScores="secondaryScores"
      @objective-score="handleSecondaryScore"
    />

    <W40KScoreActions
      :canSave="hasChanges"
      :saving="isSaving"
      @save="saveScores"
      @reset="resetChanges"
    />
  </div>
</template>

<script setup lang="ts">
// Composable pour la logique m√©tier
const {
  game,
  currentRound,
  currentRoundScores,
  secondaryScores,
  hasChanges,
  isSaving,
  canEdit,
  handleRoundChange,
  handleScoreUpdate,
  handleSecondaryScore,
  saveScores,
  resetChanges,
} = useW40KScoring(props.gameId)

// Composable pour les objectifs secondaires
const { secondaryObjectives, showSecondaries } = useW40KSecondaryObjectives(game)
</script>
```

#### **3.2 Composables Optimis√©s**

```typescript
// composables/useW40KScoring.ts
import { ref, computed, watch } from 'vue'
import { useForm } from '@inertiajs/vue3'

export function useW40KScoring(gameId: string) {
  // √âtat r√©actif centralis√©
  const game = ref<Game | null>(null)
  const currentRound = ref<number>(1)
  const scores = ref<Map<string, ScoreValue>>(new Map())
  const isSaving = ref(false)
  const hasChanges = ref(false)

  // Cache des calculs co√ªteux
  const currentRoundScores = computed(() => {
    if (!game.value) return []

    return game.value.rounds.find((r) => r.roundNumber === currentRound.value)?.scores || []
  })

  const totalScores = computed(() => {
    // Memoization des calculs de totaux
    const totals = new Map<string, number>()

    game.value?.players.forEach((player) => {
      const total = game.value!.rounds.reduce((sum, round) => {
        const playerScores = round.scores.filter((s) => s.playerId === player.id)
        return sum + playerScores.reduce((roundSum, score) => roundSum + score.value, 0)
      }, 0)

      totals.set(player.id, total)
    })

    return totals
  })

  // Actions optimis√©es
  const handleScoreUpdate = (playerId: string, scoreType: string, value: number) => {
    const key = `${playerId}-${scoreType}-${currentRound.value}`
    scores.value.set(key, { playerId, scoreType, value, roundNumber: currentRound.value })
    hasChanges.value = true
  }

  const saveScores = async () => {
    if (!hasChanges.value) return

    isSaving.value = true
    try {
      // Optimisation: batch update des scores
      const scoresToSave = Array.from(scores.value.values())

      await router.post(
        `/games/${gameId}/scores/batch`,
        {
          scores: scoresToSave,
          roundNumber: currentRound.value,
        },
        {
          preserveState: true,
          preserveScroll: true,
          onSuccess: () => {
            hasChanges.value = false
            scores.value.clear()
          },
        }
      )
    } finally {
      isSaving.value = false
    }
  }

  // Auto-save intelligent
  const debouncedSave = debounce(saveScores, 2000)
  watch(hasChanges, (newVal) => {
    if (newVal) {
      debouncedSave()
    }
  })

  return {
    game: readonly(game),
    currentRound: readonly(currentRound),
    currentRoundScores,
    totalScores,
    hasChanges: readonly(hasChanges),
    isSaving: readonly(isSaving),
    canEdit: computed(() => game.value?.canEdit ?? false),
    handleRoundChange: (round: number) => {
      currentRound.value = round
    },
    handleScoreUpdate,
    saveScores,
    resetChanges: () => {
      scores.value.clear()
      hasChanges.value = false
    },
  }
}
```

#### **3.3 Optimisation CSS Bundle**

```typescript
// tailwind.config.js - Configuration optimis√©e
import type { Config } from 'tailwindcss'

export default {
  content: [
    './inertia/**/*.vue',
    './inertia/**/*.ts',
    './resources/views/**/*.edge'
  ],

  theme: {
    extend: {
      colors: {
        // Th√®me W40K optimis√© - Design tokens
        w40k: {
          red: {
            50: '#fef2f2',
            500: '#dc2626',
            900: '#7f1d1d',
          },
          gold: {
            50: '#fefce8',
            500: '#eab308',
            900: '#713f12',
          },
          dark: {
            50: '#f8fafc',
            900: '#0f172a',
          }
        }
      },

      fontFamily: {
        'w40k': ['Cinzel', 'serif'], // Police th√©matique
      },

      animation: {
        'score-update': 'pulse 0.5s ease-in-out',
        'dice-roll': 'spin 0.3s ease-in-out',
      }
    },
  },

  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
  ],

  // Optimisations production
  experimental: {
    optimizeUniversalDefaults: true,
  },

  // JIT activ√© par d√©faut dans v3+
  jit: true,

} satisfies Config

// inertia/css/app.css - Simplifi√© drastiquement
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

/* Import Google Fonts avec display=swap pour performance */
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&display=swap');

/* Composants W40K r√©utilisables uniquement */
@layer components {
  .btn-w40k-primary {
    @apply bg-w40k-red-500 hover:bg-w40k-red-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-200;
  }

  .score-cell {
    @apply border border-gray-300 p-2 text-center font-mono text-sm focus:ring-2 focus:ring-w40k-gold-500 focus:border-transparent;
  }

  .w40k-card {
    @apply bg-white dark:bg-gray-800 shadow-lg rounded-lg border border-gray-200 dark:border-gray-700;
  }
}

/* Variables CSS custom pour les th√®mes dynamiques */
:root {
  --w40k-primary: theme('colors.w40k.red.500');
  --w40k-secondary: theme('colors.w40k.gold.500');
  --w40k-accent: theme('colors.w40k.dark.900');
}

/* Suppression de toutes les classes utilitaires manuelles */
/* Tailwind JIT les g√©n√®re automatiquement */
```

---

## üìä Phase 4: Monitoring & Observabilit√©

### **üìà Structured Logging (D√©lai: 2-3 jours)**

```typescript
// config/logger.ts - Configuration production-ready
import pino from 'pino'

const loggerConfig = pino({
  level: env.get('LOG_LEVEL', 'info'),

  // Format JSON structur√© pour analyse
  formatters: {
    level(label: string) {
      return { level: label }
    },
    log(object: any) {
      return {
        ...object,
        hostname: os.hostname(),
        pid: process.pid,
        environment: env.get('NODE_ENV'),
      }
    },
  },

  // Timestamp ISO pour parsing facile
  timestamp: pino.stdTimeFunctions.isoTime,

  // Transport pour d√©veloppement (pretty print)
  transport:
    env.get('NODE_ENV') === 'development'
      ? {
          target: 'pino-pretty',
          options: {
            colorize: true,
            ignore: 'pid,hostname',
            translateTime: 'SYS:standard',
          },
        }
      : undefined,

  // Redaction des donn√©es sensibles
  redact: {
    paths: ['password', 'token', 'authorization', 'cookie'],
    censor: '[REDACTED]',
  },
})

// Middleware de logging des requ√™tes
export class RequestLoggingMiddleware {
  async handle({ request, response }: HttpContext, next: NextFn) {
    const startTime = process.hrtime.bigint()
    const requestId = randomUUID()

    // Contexte de requ√™te
    const requestContext = {
      requestId,
      method: request.method(),
      url: request.url(),
      userAgent: request.header('user-agent'),
      ip: request.ip(),
      referer: request.header('referer'),
    }

    logger.info('Request started', requestContext)

    try {
      await next()

      const endTime = process.hrtime.bigint()
      const duration = Number(endTime - startTime) / 1000000 // ms

      logger.info('Request completed', {
        ...requestContext,
        statusCode: response.getStatus(),
        responseTime: duration,
        success: true,
      })
    } catch (error) {
      logger.error('Request failed', {
        ...requestContext,
        error: {
          message: error.message,
          stack: error.stack,
          code: error.code,
        },
      })
      throw error
    }
  }
}
```

### **üîç Performance Monitoring Int√©gr√©**

```typescript
// monitoring/performance_monitor.ts
class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map()

  // Mesure automatique des requ√™tes DB
  async measureDatabaseQuery<T>(operation: string, queryFn: () => Promise<T>): Promise<T> {
    const start = performance.now()

    try {
      const result = await queryFn()
      const duration = performance.now() - start

      this.recordMetric(`db.${operation}`, duration)

      // Alert si requ√™te lente
      if (duration > 1000) {
        logger.warn(`Slow database query detected`, {
          operation,
          duration: `${duration.toFixed(2)}ms`,
          threshold: '1000ms',
        })
      }

      return result
    } catch (error) {
      logger.error(`Database query failed`, {
        operation,
        error: error.message,
      })
      throw error
    }
  }

  // M√©triques de cache
  recordCacheHit(cacheName: string): void {
    this.recordMetric(`cache.${cacheName}.hits`, 1)
  }

  recordCacheMiss(cacheName: string): void {
    this.recordMetric(`cache.${cacheName}.misses`, 1)
  }

  // Export des m√©triques (endpoint /metrics pour monitoring externe)
  getMetrics(): Record<string, any> {
    const summary: Record<string, any> = {}

    this.metrics.forEach((values, key) => {
      summary[key] = {
        count: values.length,
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        min: Math.min(...values),
        max: Math.max(...values),
      }
    })

    return summary
  }

  private recordMetric(key: string, value: number): void {
    if (!this.metrics.has(key)) {
      this.metrics.set(key, [])
    }

    const values = this.metrics.get(key)!
    values.push(value)

    // Garder seulement les 1000 derni√®res valeurs
    if (values.length > 1000) {
      values.shift()
    }
  }
}

// Int√©gration dans les repositories
export class MonitoredLucidScoreQueryRepository extends LucidScoreQueryRepository {
  constructor(private monitor: PerformanceMonitor) {
    super()
  }

  async findByGameIdWithRounds(gameId: GameId): Promise<Score[]> {
    return await this.monitor.measureDatabaseQuery('scores.findByGameIdWithRounds', () =>
      super.findByGameIdWithRounds(gameId)
    )
  }
}
```

---

## üéñÔ∏è Phase 5: Excellence Technique Avanc√©e

### **‚ö° Optimisations Base de Donn√©es**

```sql
-- migrations/add_strategic_indices.sql
-- Indices pour les requ√™tes critiques identifi√©es

-- Index compos√© pour les games par utilisateur et statut
CREATE INDEX IF NOT EXISTS idx_games_user_status_created
ON games (user_id, status, created_at DESC);

-- Index pour les scores par game (via rounds)
CREATE INDEX IF NOT EXISTS idx_scores_game_round
ON scores (round_id)
INCLUDE (score_type, score_value, player_id);

-- Index pour les rounds par game
CREATE INDEX IF NOT EXISTS idx_rounds_game_number
ON rounds (game_id, round_number);

-- Index pour les players par game
CREATE INDEX IF NOT EXISTS idx_players_game_user
ON players (game_id, user_id)
WHERE user_id IS NOT NULL;

-- Statistiques automatiques pour l'optimiseur
ANALYZE games;
ANALYZE rounds;
ANALYZE scores;
ANALYZE players;
```

### **üß™ Testing Strategy Avanc√©e**

```typescript
// tests/performance/benchmark.spec.ts
import { test } from '@japa/runner'
import { performance } from 'perf_hooks'

test.group('Performance Benchmarks', () => {
  test('Game detail loading should be under 100ms', async ({ assert }) => {
    const gameId = new GameId('test-game-id')
    const userId = 1

    const iterations = 10
    const durations: number[] = []

    for (let i = 0; i < iterations; i++) {
      const start = performance.now()

      await gameDetailService.getGameDetail(gameId, userId)

      const end = performance.now()
      durations.push(end - start)
    }

    const avgDuration = durations.reduce((a, b) => a + b) / durations.length
    const maxDuration = Math.max(...durations)

    console.log(`Average: ${avgDuration.toFixed(2)}ms, Max: ${maxDuration.toFixed(2)}ms`)

    // Assertions de performance
    assert.isBelow(
      avgDuration,
      100,
      `Average response time ${avgDuration.toFixed(2)}ms exceeds 100ms`
    )
    assert.isBelow(maxDuration, 200, `Max response time ${maxDuration.toFixed(2)}ms exceeds 200ms`)
  })

  test('Cache should improve performance by 80%+', async ({ assert }) => {
    const gameId = new GameId('cache-test-game')

    // Premier appel (sans cache)
    const start1 = performance.now()
    await gameDetailService.getGameDetail(gameId, 1)
    const uncachedDuration = performance.now() - start1

    // Deuxi√®me appel (avec cache)
    const start2 = performance.now()
    await gameDetailService.getGameDetail(gameId, 1)
    const cachedDuration = performance.now() - start2

    const improvement = ((uncachedDuration - cachedDuration) / uncachedDuration) * 100

    console.log(`Cache improvement: ${improvement.toFixed(1)}%`)
    assert.isAbove(improvement, 80, `Cache improvement ${improvement.toFixed(1)}% is below 80%`)
  })
})
```

---

## üìÖ Roadmap d'Impl√©mentation D√©taill√©e

### **Sprint 1: S√©curit√© Critique (3-5 jours)**

```
Jour 1-2: üö® Corrections s√©curitaires
‚îú‚îÄ‚îÄ √âlimination logs sensibles
‚îú‚îÄ‚îÄ Configuration CORS restrictive
‚îú‚îÄ‚îÄ Activation CSP compl√®te
‚îî‚îÄ‚îÄ Tests s√©curitaires

Jour 3-4: üõ°Ô∏è Rate limiting √©tendu
‚îú‚îÄ‚îÄ Middleware rate limiting avanc√©
‚îú‚îÄ‚îÄ Configuration par endpoint
‚îú‚îÄ‚îÄ Logging des tentatives
‚îî‚îÄ‚îÄ Tests de charge

Jour 5: ‚úÖ Validation s√©curitaire
‚îú‚îÄ‚îÄ Audit s√©curitaire complet
‚îú‚îÄ‚îÄ Tests d'intrusion basiques
‚îî‚îÄ‚îÄ Documentation s√©curitaire
```

### **Sprint 2: Performance Critique (5-7 jours)**

```
Jour 1-2: üöÄ R√©solution N+1
‚îú‚îÄ‚îÄ Nouvelles m√©thodes repository
‚îú‚îÄ‚îÄ Requ√™tes optimis√©es avec JOIN
‚îú‚îÄ‚îÄ Tests de performance
‚îî‚îÄ‚îÄ Benchmarks avant/apr√®s

Jour 3-4: üèóÔ∏è Injection d√©pendances
‚îú‚îÄ‚îÄ Provider IoC
‚îú‚îÄ‚îÄ Refactoring contr√¥leurs
‚îú‚îÄ‚îÄ Services singletons
‚îî‚îÄ‚îÄ Tests d'int√©gration

Jour 5-7: üíæ Cache applicatif
‚îú‚îÄ‚îÄ MemoryCacheService
‚îú‚îÄ‚îÄ Int√©gration services
‚îú‚îÄ‚îÄ Invalidation intelligente
‚îî‚îÄ‚îÄ M√©triques cache
```

### **Sprint 3: Frontend Optimis√© (5-7 jours)**

```
Jour 1-3: üß© D√©composition composants
‚îú‚îÄ‚îÄ Refactoring W40KScoreBoard
‚îú‚îÄ‚îÄ Composables m√©tier
‚îú‚îÄ‚îÄ √âtats r√©actifs optimis√©s
‚îî‚îÄ‚îÄ Tests composants

Jour 4-5: üé® Optimisation CSS
‚îú‚îÄ‚îÄ Configuration Tailwind JIT
‚îú‚îÄ‚îÄ Suppression utilities manuelles
‚îú‚îÄ‚îÄ Design tokens W40K
‚îî‚îÄ‚îÄ Bundle size analysis

Jour 6-7: ‚ö° Performance frontend
‚îú‚îÄ‚îÄ Lazy loading composants
‚îú‚îÄ‚îÄ Virtual scrolling si n√©cessaire
‚îú‚îÄ‚îÄ Optimisation images
‚îî‚îÄ‚îÄ Tests Lighthouse
```

### **Sprint 4: Monitoring & Finitions (3-5 jours)**

```
Jour 1-2: üìä Structured logging
‚îú‚îÄ‚îÄ Configuration Pino
‚îú‚îÄ‚îÄ Middleware logging
‚îú‚îÄ‚îÄ Contextes de requ√™te
‚îî‚îÄ‚îÄ Redaction donn√©es sensibles

Jour 3-4: üîç Performance monitoring
‚îú‚îÄ‚îÄ M√©triques automatiques
‚îú‚îÄ‚îÄ Monitoring DB queries
‚îú‚îÄ‚îÄ Cache hit/miss tracking
‚îî‚îÄ‚îÄ Endpoint /metrics

Jour 5: üéñÔ∏è Excellence technique
‚îú‚îÄ‚îÄ Indices base de donn√©es
‚îú‚îÄ‚îÄ Tests performance
‚îú‚îÄ‚îÄ Documentation compl√®te
‚îî‚îÄ‚îÄ D√©ploiement final
```

---

## üéØ R√©sultats Attendus

### **M√©triques de Performance**

- ‚ö° **Temps de r√©ponse**: <100ms (vs 500ms+ actuellement)
- üéØ **Requ√™tes DB**: -85% (1 requ√™te au lieu de 6+)
- üíæ **Cache hit ratio**: >90% pour donn√©es fr√©quentes
- üì¶ **Bundle JS**: -40% apr√®s optimisation CSS
- üöÄ **Lighthouse Score**: >95 (Performance, Accessibility, Best Practices)

### **M√©triques de S√©curit√©**

- üõ°Ô∏è **Vuln√©rabilit√©s**: 0 critique, 0 haute priorit√©
- üîí **Headers s√©curitaires**: 100% compliance
- üö® **Rate limiting**: Protection compl√®te endpoints
- üìù **Audit logs**: Tra√ßabilit√© compl√®te actions sensibles

### **M√©triques de Qualit√©**

- üìä **Test coverage**: >90% domaine, >80% application
- üèóÔ∏è **Architecture compliance**: 100% respect principes DDD/Hexagonal
- üßπ **Technical debt**: -70% apr√®s refactoring
- üìö **Documentation**: Sp√©cifications techniques compl√®tes

---

## üí° Recommandations Bonus

### **√âvolutions Futures (6+ mois)**

1. **API GraphQL** pour frontend avanc√©
2. **WebSockets** pour scores temps r√©el
3. **PWA** pour usage mobile/offline
4. **Microservices** si croissance importante
5. **IA/ML** pour analyse statistiques W40K

### **Stack Technique Recommand√©e √† Long Terme**

```
Production Stack:
‚îú‚îÄ‚îÄ Backend: AdonisJS 6 + PostgreSQL + Redis (si budget)
‚îú‚îÄ‚îÄ Frontend: Vue 3 + Inertia.js + Tailwind v4
‚îú‚îÄ‚îÄ Monitoring: Pino + Grafana/Prometheus (si budget)
‚îú‚îÄ‚îÄ Deployment: Docker + Traefik/Caddy
‚îî‚îÄ‚îÄ CI/CD: GitHub Actions + Automated testing
```

Ce plan vous donnera une application W40K scoring de **qualit√© industrielle** avec d'excellentes performances, une s√©curit√© robuste, et une architecture √©volutive. L'approche progressive permet d'impl√©menter par priorit√© tout en maintenant la qualit√©.

√ätes-vous pr√™t √† commencer par la Phase 1 (S√©curit√© Critique) ?
