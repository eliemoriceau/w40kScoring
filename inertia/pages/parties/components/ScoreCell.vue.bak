<template>
  <div :class="cellClasses" @click="startEditing">
    <!-- Mode affichage -->
    <div v-if="!isEditing" class="score-display">
      <span class="score-value">{{ displayScore }}</span>
      <svg
        v-if="showEditIcon"
        class="edit-icon"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
        />
      </svg>
    </div>

    <!-- Mode édition -->
    <div v-else class="score-edit">
      <input
        ref="scoreInput"
        v-model.number="editValue"
        :min="0"
        :max="maxScore"
        type="number"
        class="score-input"
        @blur="saveScore"
        @keyup.enter="saveScore"
        @keyup.escape="cancelEdit"
        @keyup.arrow-up="incrementScore"
        @keyup.arrow-down="decrementScore"
        @input="validateInput"
      />
      <div class="edit-actions">
        <button @click="saveScore" class="save-btn" title="Sauvegarder">✓</button>
        <button @click="cancelEdit" class="cancel-btn" title="Annuler">✕</button>
      </div>
    </div>

    <!-- Indicateur de sauvegarde -->
    <div v-if="isSaving" class="saving-indicator">
      <svg class="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" />
        <path
          class="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </svg>
    </div>

    <!-- Indicateur d'erreur -->
    <div v-if="hasError" class="error-indicator" title="Erreur de sauvegarde">
      <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
        />
      </svg>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, nextTick, watch } from 'vue'
import { router } from '@inertiajs/vue3'
import type { ScoreCellProps, ScoreUpdateEvent } from '../types'

const props = withDefaults(defineProps<ScoreCellProps>(), {
  scoreType: 'primary',
  current: false,
})

const emit = defineEmits<{
  'score-updated': [event: ScoreUpdateEvent]
  'editing-started': []
  'editing-ended': []
}>()

// État local
const isEditing = ref(false)
const editValue = ref(0)
const isSaving = ref(false)
const hasError = ref(false)
const scoreInput = ref<HTMLInputElement>()

// Configuration des scores
const SCORE_LIMITS = {
  primary: { min: 0, max: 50 },
  secondary: { min: 0, max: 15 },
} as const

// Score maximum selon le type
const maxScore = computed(() => SCORE_LIMITS[props.scoreType].max)
const minScore = computed(() => SCORE_LIMITS[props.scoreType].min)

// Score actuel à afficher (défaut 0)
const currentScore = computed(() => {
  if (props.scoreType === 'secondary') {
    // TODO: Implémenter les scores secondaires quand disponibles
    return 0
  }

  const score = props.player.isMainPlayer
    ? props.round.playerScore
    : props.round.opponentScore
    
  return score ?? 0
})

const displayScore = computed(() => currentScore.value)

const showEditIcon = computed(() => props.editable && !isEditing.value && !isSaving.value)

const cellClasses = computed(() => {
  const score = currentScore.value
  return [
    'score-cell',
    {
      'cell-editable': props.editable,
      'cell-editing': isEditing.value,
      'cell-current': props.current,
      'cell-completed': score > 0,
      'cell-empty': score === 0,
      'cell-saving': isSaving.value,
      'cell-error': hasError.value,
    },
  ]
})

// Démarrer l'édition
const startEditing = async () => {
  if (!props.editable || isEditing.value || isSaving.value) return

  isEditing.value = true
  editValue.value = currentScore.value ?? 0
  hasError.value = false
  emit('editing-started')

  await nextTick()
  scoreInput.value?.focus()
  scoreInput.value?.select()
}

// Validation du score
const validateScore = (score: number): boolean => {
  return score >= minScore.value && score <= maxScore.value && Number.isInteger(score)
}

// Sauvegarder le score
const saveScore = async () => {
  if (!isEditing.value || isSaving.value) return

  const newScore = editValue.value

  // Validation
  if (!validateScore(newScore)) {
    hasError.value = true
    return
  }

  // Pas de changement
  if (newScore === currentScore.value) {
    cancelEdit()
    return
  }

  isSaving.value = true
  hasError.value = false

  try {
    // Appel à l'API Phase 1
    await router.put(
      `/parties/${props.gameId}/rounds/${props.round.id}/score`,
      {
        playerId: props.player.id,
        score: newScore,
      },
      {
        preserveState: true,
        preserveScroll: true,
        onSuccess: () => {
          // Émettre l'événement de mise à jour
          emit('score-updated', {
            roundId: props.round.id,
            playerId: props.player.id,
            score: newScore,
            scoreType: props.scoreType,
          })

          isEditing.value = false
          emit('editing-ended')
        },
        onError: () => {
          hasError.value = true
        },
      }
    )
  } catch (error) {
    hasError.value = true
    console.error('Erreur lors de la sauvegarde du score:', error)
  } finally {
    isSaving.value = false
  }
}

// Annuler l'édition
const cancelEdit = () => {
  isEditing.value = false
  editValue.value = currentScore.value ?? 0
  hasError.value = false
  emit('editing-ended')
}

// Navigation clavier
const incrementScore = () => {
  const newValue = editValue.value + 1
  if (newValue <= maxScore.value) {
    editValue.value = newValue
    hasError.value = false
  }
}

const decrementScore = () => {
  const newValue = editValue.value - 1
  if (newValue >= minScore.value) {
    editValue.value = newValue
    hasError.value = false
  }
}

// Validation en temps réel
const validateInput = () => {
  const value = editValue.value
  
  if (value > maxScore.value) {
    editValue.value = maxScore.value
  } else if (value < minScore.value) {
    editValue.value = minScore.value
  }
  
  // Reset l'erreur si la valeur est maintenant valide
  if (validateScore(editValue.value)) {
    hasError.value = false
  }
}

// Reset de l'erreur quand on commence à éditer
watch(isEditing, (newValue) => {
  if (newValue) {
    hasError.value = false
  }
})
</script>

<!-- <style scoped> TEMPORAIREMENT DÉSACTIVÉ - @apply incompatible avec Tailwind CSS v4
.score-cell {
  @apply relative min-h-[3rem] flex items-center justify-center
         border-2 border-transparent rounded-lg p-2
         transition-all duration-200 cursor-pointer;
}

.cell-editable:hover {
  @apply border-red-300 bg-red-900/10;
}

.cell-editing {
  @apply border-red-500 bg-red-900/20 shadow-lg;
}

.cell-current {
  @apply border-orange-300 bg-orange-900/20;
}

.cell-completed {
  @apply border-green-300 bg-green-900/10;
}

.cell-empty {
  @apply border-gray-400 bg-gray-800/50;
}

.cell-saving {
  @apply border-blue-400 bg-blue-900/20;
}

.cell-error {
  @apply border-red-600 bg-red-900/30;
}

.score-display {
  @apply flex items-center gap-2;
}

.score-value {
  @apply text-xl font-bold text-white;
}

.edit-icon {
  @apply w-4 h-4 text-gray-400 opacity-0 transition-opacity;
}

.cell-editable:hover .edit-icon {
  @apply opacity-100;
}

.score-edit {
  @apply flex items-center gap-2;
}

.score-input {
  @apply w-16 px-2 py-1 text-center font-bold
         bg-slate-700 border border-red-500 rounded
         text-white focus:outline-none focus:ring-2 focus:ring-red-300;
}

.edit-actions {
  @apply flex gap-1;
}

.save-btn,
.cancel-btn {
  @apply w-6 h-6 flex items-center justify-center rounded
         text-xs font-bold transition-colors;
}

.save-btn {
  @apply bg-green-600 hover:bg-green-500 text-white;
}

.cancel-btn {
  @apply bg-red-600 hover:bg-red-500 text-white;
}

.saving-indicator {
  @apply absolute top-1 right-1 text-blue-400;
}

.error-indicator {
  @apply absolute top-1 right-1 text-red-400;
}

/* Animation pour les transitions */
.score-cell {
  transition:
    border-color 0.2s ease,
    background-color 0.2s ease,
    transform 0.1s ease;
}

.cell-editing {
  transform: scale(1.02);
}

/* Responsive */
@media (max-width: 768px) {
  .score-cell {
    @apply min-h-[2.5rem];
  }

  .score-value {
    @apply text-lg;
  }

  .score-input {
    @apply w-14 text-sm;
  }

  .save-btn,
  .cancel-btn {
    @apply w-8 h-8 text-sm;
  }
}
</style>
